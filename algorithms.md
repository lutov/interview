↩ [Оглавление](https://github.com/lutov/interview/blob/main/README.md)

# Алгоритмы

    * Оценка сложности алгоритмов
    * Двоичный поиск
        * Поиск элемента в отсортированном массиве
        * Как найти фальшивую монету с помощью весов
    * Пузырьковая сортировка
    * Как увеличить каждый элемент массива не в цикле

## Оценка сложности алгоритмов

Совокупность приемов и формул, позволяющих вычислить, сколько времени потребуется на выполнение алгоритма, либо какой объем памяти для этого понадобится.

Сложность записывается как O(n), где n - число элементов, которые нужно обработать. Примеры по возрастанию сложности:

* O(1) - одна операция при любом количестве элементов

* O(n) - по одной операции на каждый элемент

* O(log(n, 2)) - логарифм операций от числа элементов по основанию 2

* O(pow(n, 2)) - по одной операции на каждый элемент за проход, число проходов равно количеству элементов
    
* O(n!) - факториал количества элементов

Если известно количество элементов и длительность одной операции, то, зная сложность алгоритма, можно подсчитать, сколько времени займет обработка всех элементов. В разных алгоритмах число операций растет с разной скоростью, некоторые алгоритмы при большом увеличении чила элементов требуют лишь незначительного увеличения числа операций.

## Двоичный поиск

Двоичный (бинарный) поиск (также известен как метод деления пополам или дихотомия) — классический алгоритм поиска элемента в отсортированном массиве (векторе), использующий дробление массива на половины.

### Поиск элемента в отсортированном массиве

Определение значения элемента в середине структуры данных. Полученное значение сравнивается с ключом.

Если ключ меньше значения середины, то поиск осуществляется в первой половине элементов, иначе — во второй.

Поиск сводится к тому, что вновь определяется значение серединного элемента в выбранной половине и сравнивается с ключом.

Процесс продолжается до тех пор, пока не будет найден элемент со значением ключа или не станет пустым интервал для поиска.

### Как найти фальшивую монету с помощью весов

Вы можете столкнуться с разными вариантами подобной задачи: монет может быть сколько угодно, и определить фальшивую нужно будет за минимальное число взвешиваний. Хитрость решения состоит в том, что делить монеты нужно не на две, а на три части, так как уравновешивание чашек весов позволяет сделать определенный вывод не только о тех монетах, которые лежат на весах, но и о тех, которые остались на столе.

## Пузырьковая сортировка

Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются N − 1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на своё место в конце массива рядом с предыдущим «наибольшим элементом», а наименьший элемент перемещается на одну позицию к началу массива («всплывает» до нужной позиции, как пузырёк в воде, отсюда и название алгоритма).

## Как увеличить каждый элемент массива не в цикле

С помощью функции обратного вызова, например array_map() для php. Вопрос не имеет практического значения, но должен сигнализировать о знакомстве с концепцией MapReduce, которая далее может вести к обсуждению параллельных вычислений.
