← [Оглавление](https://github.com/lutov/interview/blob/main/README.md)

# JavaScript

    * Стрелочные функции
        * Ситуации, в которых стрелочные функции улучшают код
            * Обработка списков значений
            * Промисы и цепочки промисов
            * Трансформация объектов
        * Ситуации, в которых не следует использовать стрелочные функции
            * Методы объектов
            * Длинные цепочки вызовов
            * Функции с динамическим контекстом
            
## Стрелочные функции

Стрелочные функции в JavaScript — это анонимные функции с особым синтаксисом, которые принимают фиксированное число аргументов и работают в контексте включающей их области видимости, то есть — в контексте функции или другого кода, в котором они объявлены.

Стрелочные функции строятся по единой схеме, при этом структура функций может быть, в особых случаях, упрощена. Базовая структура стрелочной функции выглядит так:

```javascript
(argument1, argument2, ... argumentN) => {
  // тело функции
}
```

Список аргументов функции находится в круглых скобках, после него следует стрелка, составленная из символов = и >, а дальше идёт тело функции в фигурных скобках.

В отличие от других функций, стрелочные функции не имеют собственного контекста выполнения.

На практике это означает, что они наследуют сущности this и arguments от родительской функции.

### Ситуации, в которых стрелочные функции улучшают код

#### Обработка списков значений

Традиционными лямбда-функциями, а также — стрелочными функциями, после появления их в JavaScript, обычно пользуются в ситуации, когда некая функция применяется к каждому элементу некоего списка.

Вот чрезвычайно распространённый пример подобного использования стрелочных функций, который заключается в работе со свойствами объектов:

```javascript
const names = objects.map(object => object.name);
```

#### Промисы и цепочки промисов

При использовании промисов нужно объявлять функции, которые вызываются после завершения работы асинхронного кода или завершения асинхронного обращения к некоему API.

Это — идеальное место для использования стрелочных функций, в особенности в том случае, если результирующая функция обладает неким состоянием, ссылается на что-либо в объекте. Например, это может выглядеть так:

```javascript
this.doSomethingAsync().then((result) => {
  this.storeResult(result);
});
```

#### Трансформация объектов

Во Vue.js существует общепринятый паттерн включения фрагментов хранилища Vuex напрямую в компонент Vue с использованием mapState.

Эта операция включает в себя объявления набора «преобразователей», которые выбирают из исходного полного состояния именно то, что нужно для конкретного компонента.

Такие простые преобразования — идеальное место для использования стрелочных функций. Например:

```javascript
export default {
  computed: {
    ...mapState({
      results: state => state.results,
      users: state => state.users,
    })
  }
}
```

### Ситуации, в которых не следует использовать стрелочные функции

#### Методы объектов

#### Длинные цепочки вызовов

Основная причина подобных проблем, как и при использовании анонимных функций, заключается в том, что они дают крайне неинформативные результаты трассировки стека вызовов.

#### Функции с динамическим контекстом
